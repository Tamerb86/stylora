import { useState } from "react";
import { Link, useLocation } from "wouter";
import { useTranslation } from "react-i18next";
import { trpc } from "@/lib/trpc";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { UserPlus, Play, X, Clock, Users, MessageSquare, SkipForward, AlertCircle, Crown, Zap, Tv } from "lucide-react";
import { toast } from "sonner";
import { format, formatDistanceToNow } from "date-fns";
import { nb, ar, enUS, uk } from "date-fns/locale";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

export function WalkInQueue() {
  const { t, i18n } = useTranslation();
  const [, setLocation] = useLocation();
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [editPriorityDialog, setEditPriorityDialog] = useState<{ open: boolean; queueId: number | null; currentPriority: string; currentReason: string }>({
    open: false,
    queueId: null,
    currentPriority: "normal",
    currentReason: "",
  });
  const [newCustomer, setNewCustomer] = useState({
    customerName: "",
    customerPhone: "",
    serviceId: "",
    preferredEmployeeId: "",
    priority: "normal" as "normal" | "urgent" | "vip",
    priorityReason: "",
  });

  // Get date-fns locale based on current language
  const getDateLocale = () => {
    switch (i18n.language) {
      case 'ar': return ar;
      case 'en': return enUS;
      case 'uk': return uk;
      default: return nb;
    }
  };

  // Fetch queue with auto-refresh every 30 seconds
  const { data: queue, refetch } = trpc.walkInQueue.getQueue.useQuery(undefined, {
    refetchInterval: 30000, // 30 seconds
  });

  const { data: barberStats } = trpc.walkInQueue.getAvailableBarbers.useQuery(undefined, {
    refetchInterval: 30000,
  });

  // Fetch intelligent wait times
  const { data: waitTimesData } = trpc.walkInQueue.calculateWaitTimes.useQuery(undefined, {
    refetchInterval: 30000, // Auto-refresh every 30 seconds
  });

  const { data: services } = trpc.services.list.useQuery();
  // Get tenantId from auth context
  const { data: authData } = trpc.auth.me.useQuery();
  const { data: employees } = trpc.publicBooking.getAvailableEmployees.useQuery(
    { tenantId: authData?.tenantId || "" },
    { enabled: !!authData?.tenantId }
  );

  const addToQueue = trpc.walkInQueue.addToQueue.useMutation({
    onSuccess: () => {
      toast.success(t('walkInQueue.successAdded'));
      setIsAddDialogOpen(false);
      setNewCustomer({ 
        customerName: "", 
        customerPhone: "", 
        serviceId: "", 
        preferredEmployeeId: "",
        priority: "normal",
        priorityReason: "",
      });
      refetch();
    },
    onError: (error: any) => {
      toast.error(error.message || t('walkInQueue.errorAdd'));
    },
  });

  const startService = trpc.walkInQueue.startService.useMutation({
    onSuccess: () => {
      toast.success(t('walkInQueue.successStarted'));
      refetch();
    },
    onError: (error: any) => {
      toast.error(error.message || t('walkInQueue.errorStart'));
    },
  });

  const removeFromQueue = trpc.walkInQueue.removeFromQueue.useMutation({
    onSuccess: () => {
      toast.success(t('walkInQueue.successRemoved'));
      refetch();
    },
    onError: (error: any) => {
      toast.error(error.message || t('walkInQueue.errorRemove'));
    },
  });

  const updatePriority = trpc.walkInQueue.updatePriority.useMutation({
    onSuccess: () => {
      toast.success(t('walkInQueue.successPriorityUpdated'));
      setEditPriorityDialog({ open: false, queueId: null, currentPriority: "normal", currentReason: "" });
      refetch();
    },
    onError: (error: any) => {
      toast.error(error.message || t('walkInQueue.errorPriority'));
    },
  });

  const completeService = trpc.walkInQueue.completeService.useMutation({
    onSuccess: (data: any) => {
      toast.success(t('walkInQueue.successCompleted'));
      refetch();
      // Navigate to POS with pre-selected service and customer info
      const service = services?.find((s: any) => s.id === data.serviceId);
      if (service) {
        // Store customer and service info in sessionStorage for POS to pick up
        sessionStorage.setItem('pos_preselect', JSON.stringify({
          customerName: data.customerName,
          customerPhone: data.customerPhone,
          serviceId: data.serviceId,
          serviceName: service.name,
          servicePrice: service.price,
        }));
        setLocation('/pos');
      }
    },
    onError: (error: any) => {
      toast.error(error.message || t('walkInQueue.errorComplete'));
    },
  });

  const handleAddToQueue = () => {
    if (!newCustomer.customerName || !newCustomer.customerPhone) {
      toast.error(t('walkInQueue.errorNamePhone'));
      return;
    }

    if (!newCustomer.serviceId) {
      toast.error(t('walkInQueue.errorService'));
      return;
    }

    if ((newCustomer.priority === "urgent" || newCustomer.priority === "vip") && !newCustomer.priorityReason) {
      toast.error(t('walkInQueue.errorPriorityReason'));
      return;
    }

    addToQueue.mutate({
      customerName: newCustomer.customerName,
      customerPhone: newCustomer.customerPhone,
      serviceId: Number(newCustomer.serviceId),
      employeeId: newCustomer.preferredEmployeeId ? Number(newCustomer.preferredEmployeeId) : undefined,
      priority: newCustomer.priority,
      priorityReason: newCustomer.priorityReason || undefined,
    });
  };

  const handleStartService = (queueId: number) => {
    if (confirm(t('walkInQueue.confirmStart'))) {
      startService.mutate({ queueId });
    }
  };

  const handleRemove = (queueId: number, customerName: string) => {
    if (confirm(t('walkInQueue.confirmRemove', { name: customerName }))) {
      removeFromQueue.mutate({ queueId });
    }
  };

  const handleUpdatePriority = () => {
    if (!editPriorityDialog.queueId) return;

    updatePriority.mutate({
      queueId: editPriorityDialog.queueId,
      priority: editPriorityDialog.currentPriority as "normal" | "urgent" | "vip",
      priorityReason: editPriorityDialog.currentReason || undefined,
    });
  };

  const handleCompleteService = (queueId: number) => {
    if (confirm(t('walkInQueue.confirmComplete'))) {
      completeService.mutate({ queueId });
    }
  };

  const handleNotify = (queueId: number) => {
    toast.info(t('walkInQueue.smsNotification'));
  };

  // Get intelligent wait time from backend calculation
  const getIntelligentWaitTime = (queueId: number) => {
    const waitTimeInfo = waitTimesData?.waitTimes?.find((wt: any) => wt.queueId === queueId);
    if (waitTimeInfo) {
      const estimated = waitTimeInfo.estimatedWaitMinutes;
      return {
        min: Math.max(0, estimated - 5),
        max: estimated + 5,
        estimated,
        color: waitTimeInfo.color,
      };
    }
    // Fallback to simple calculation if backend data not available
    return { min: 10, max: 20, estimated: 15, color: "green" };
  };

  const getPriorityBadge = (priority: string, reason?: string) => {
    const badges = {
      vip: {
        icon: <Crown className="h-3 w-3" />,
        label: t('walkInQueue.vip'),
        className: "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200 border-purple-300",
      },
      urgent: {
        icon: <Zap className="h-3 w-3" />,
        label: t('walkInQueue.urgent'),
        className: "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200 border-orange-300",
      },
      normal: {
        icon: <Users className="h-3 w-3" />,
        label: t('walkInQueue.normal'),
        className: "bg-gray-100 text-gray-800 dark:bg-gray-800 dark:text-gray-200 border-gray-300",
      },
    };

    const badge = badges[priority as keyof typeof badges] || badges.normal;

    return (
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Badge variant="outline" className={`gap-1 ${badge.className}`}>
              {badge.icon}
              {badge.label}
            </Badge>
          </TooltipTrigger>
          {reason && (
            <TooltipContent>
              <p className="text-sm">{t('walkInQueue.reason')}: {reason}</p>
            </TooltipContent>
          )}
        </Tooltip>
      </TooltipProvider>
    );
  };

  const getWaitTimeColorByName = (color: string) => {
    const colorMap: Record<string, string> = {
      green: "text-green-600 dark:text-green-400",
      yellow: "text-yellow-600 dark:text-yellow-400",
      orange: "text-orange-600 dark:text-orange-400",
      red: "text-red-600 dark:text-red-400",
    };
    return colorMap[color] || "text-gray-600 dark:text-gray-400";
  };

  const getWaitTimeBgByName = (color: string) => {
    const bgMap: Record<string, string> = {
      green: "bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800",
      yellow: "bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800",
      orange: "bg-orange-50 dark:bg-orange-900/20 border-orange-200 dark:border-orange-800",
      red: "bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800",
    };
    return bgMap[color] || "bg-gray-50 dark:bg-gray-900/20 border-gray-200 dark:border-gray-800";
  };

  // Legacy functions for backward compatibility
  const getWaitTimeColor = (minutes: number) => {
    if (minutes < 15) return "text-green-600 dark:text-green-400";
    if (minutes < 30) return "text-yellow-600 dark:text-yellow-400";
    if (minutes < 45) return "text-orange-600 dark:text-orange-400";
    return "text-red-600 dark:text-red-400";
  };

  const getWaitTimeBg = (minutes: number) => {
    if (minutes < 15) return "bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800";
    if (minutes < 30) return "bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800";
    if (minutes < 45) return "bg-orange-50 dark:bg-orange-900/20 border-orange-200 dark:border-orange-800";
    return "bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800";
  };

  // Sort queue by priority (VIP → Urgent → Normal) then by position
  const sortedQueue = [...(queue || [])].sort((a, b) => {
    const priorityOrder = { vip: 0, urgent: 1, normal: 2 };
    const aPriority = priorityOrder[a.priority as keyof typeof priorityOrder] ?? 2;
    const bPriority = priorityOrder[b.priority as keyof typeof priorityOrder] ?? 2;
    
    if (aPriority !== bPriority) return aPriority - bPriority;
    return a.position - b.position;
  });

  const waitingCustomers = sortedQueue.filter((q: any) => q.status === "waiting") || [];
  const inServiceCustomers = sortedQueue.filter((q: any) => q.status === "in_service") || [];
  const averageWaitTime = waitingCustomers.length > 0
    ? Math.floor(waitingCustomers.reduce((sum: number, q: any) => {
        const waitTime = getIntelligentWaitTime(q.id);
        return sum + waitTime.estimated;
      }, 0) / waitingCustomers.length)
    : 0;
